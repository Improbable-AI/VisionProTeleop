// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: mujoco_ar.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request to send USDZ URL
public struct MujocoAr_UsdzUrlRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var usdzURL: String = String()

  public var sessionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for USDZ URL
public struct MujocoAr_UsdzUrlResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to send USDZ file data
public struct MujocoAr_UsdzDataRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var usdzData: Data = Data()

  public var filename: String = String()

  public var sessionID: String = String()

  public var attachToPosition: MujocoAr_Vector3 {
    get {return _attachToPosition ?? MujocoAr_Vector3()}
    set {_attachToPosition = newValue}
  }
  /// Returns true if `attachToPosition` has been explicitly set.
  public var hasAttachToPosition: Bool {return self._attachToPosition != nil}
  /// Clears the value of `attachToPosition`. Subsequent reads from it will return its default value.
  public mutating func clearAttachToPosition() {self._attachToPosition = nil}

  public var attachToRotation: MujocoAr_Quaternion {
    get {return _attachToRotation ?? MujocoAr_Quaternion()}
    set {_attachToRotation = newValue}
  }
  /// Returns true if `attachToRotation` has been explicitly set.
  public var hasAttachToRotation: Bool {return self._attachToRotation != nil}
  /// Clears the value of `attachToRotation`. Subsequent reads from it will return its default value.
  public mutating func clearAttachToRotation() {self._attachToRotation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _attachToPosition: MujocoAr_Vector3? = nil
  fileprivate var _attachToRotation: MujocoAr_Quaternion? = nil
}

/// Request for chunked USDZ file transfer
public struct MujocoAr_UsdzChunkRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chunkData: Data = Data()

  public var filename: String = String()

  public var sessionID: String = String()

  public var chunkIndex: Int32 = 0

  public var totalChunks: Int32 = 0

  public var totalSize: Int64 = 0

  public var isLastChunk: Bool = false

  public var attachToPosition: MujocoAr_Vector3 {
    get {return _attachToPosition ?? MujocoAr_Vector3()}
    set {_attachToPosition = newValue}
  }
  /// Returns true if `attachToPosition` has been explicitly set.
  public var hasAttachToPosition: Bool {return self._attachToPosition != nil}
  /// Clears the value of `attachToPosition`. Subsequent reads from it will return its default value.
  public mutating func clearAttachToPosition() {self._attachToPosition = nil}

  public var attachToRotation: MujocoAr_Quaternion {
    get {return _attachToRotation ?? MujocoAr_Quaternion()}
    set {_attachToRotation = newValue}
  }
  /// Returns true if `attachToRotation` has been explicitly set.
  public var hasAttachToRotation: Bool {return self._attachToRotation != nil}
  /// Clears the value of `attachToRotation`. Subsequent reads from it will return its default value.
  public mutating func clearAttachToRotation() {self._attachToRotation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _attachToPosition: MujocoAr_Vector3? = nil
  fileprivate var _attachToRotation: MujocoAr_Quaternion? = nil
}

/// Response for USDZ data
public struct MujocoAr_UsdzDataResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var message: String = String()

  public var localFilePath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 3D Vector for position
public struct MujocoAr_Vector3: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var x: Float = 0

  public var y: Float = 0

  public var z: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Quaternion for rotation
public struct MujocoAr_Quaternion: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var x: Float = 0

  public var y: Float = 0

  public var z: Float = 0

  public var w: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Body pose containing position and rotation
public struct MujocoAr_BodyPose: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var position: MujocoAr_Vector3 {
    get {return _position ?? MujocoAr_Vector3()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  public var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  public mutating func clearPosition() {self._position = nil}

  public var rotation: MujocoAr_Quaternion {
    get {return _rotation ?? MujocoAr_Quaternion()}
    set {_rotation = newValue}
  }
  /// Returns true if `rotation` has been explicitly set.
  public var hasRotation: Bool {return self._rotation != nil}
  /// Clears the value of `rotation`. Subsequent reads from it will return its default value.
  public mutating func clearRotation() {self._rotation = nil}

  public var bodyName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _position: MujocoAr_Vector3? = nil
  fileprivate var _rotation: MujocoAr_Quaternion? = nil
}

/// Request containing multiple body poses
public struct MujocoAr_PoseUpdateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var bodyPoses: [MujocoAr_BodyPose] = []

  public var sessionID: String = String()

  public var timestamp: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for pose updates
public struct MujocoAr_PoseUpdateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var message: String = String()

  public var bodiesUpdated: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a 4x4 transformation matrix
public struct MujocoAr_Matrix4x4: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var m00: Float = 0

  public var m01: Float = 0

  public var m02: Float = 0

  public var m03: Float = 0

  public var m10: Float = 0

  public var m11: Float = 0

  public var m12: Float = 0

  public var m13: Float = 0

  public var m20: Float = 0

  public var m21: Float = 0

  public var m22: Float = 0

  public var m23: Float = 0

  public var m30: Float = 0

  public var m31: Float = 0

  public var m32: Float = 0

  public var m33: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The skeleton of a hand, comprising multiple 4x4 matrices (one per joint)
public struct MujocoAr_HandSkeleton: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Array of 4x4 matrices, expecting 25 per hand
  public var jointMatrices: [MujocoAr_Matrix4x4] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The hand tracking information, including the full 4x4 matrix for the wrist and the skeleton
public struct MujocoAr_Hand: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 4x4 matrix for the wrist position and orientation
  public var wristMatrix: MujocoAr_Matrix4x4 {
    get {return _storage._wristMatrix ?? MujocoAr_Matrix4x4()}
    set {_uniqueStorage()._wristMatrix = newValue}
  }
  /// Returns true if `wristMatrix` has been explicitly set.
  public var hasWristMatrix: Bool {return _storage._wristMatrix != nil}
  /// Clears the value of `wristMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearWristMatrix() {_uniqueStorage()._wristMatrix = nil}

  /// The hand's skeleton
  public var skeleton: MujocoAr_HandSkeleton {
    get {return _storage._skeleton ?? MujocoAr_HandSkeleton()}
    set {_uniqueStorage()._skeleton = newValue}
  }
  /// Returns true if `skeleton` has been explicitly set.
  public var hasSkeleton: Bool {return _storage._skeleton != nil}
  /// Clears the value of `skeleton`. Subsequent reads from it will return its default value.
  public mutating func clearSkeleton() {_uniqueStorage()._skeleton = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The overall hand tracking update message, including data for both hands and head
public struct MujocoAr_HandTrackingUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var leftHand: MujocoAr_Hand {
    get {return _storage._leftHand ?? MujocoAr_Hand()}
    set {_uniqueStorage()._leftHand = newValue}
  }
  /// Returns true if `leftHand` has been explicitly set.
  public var hasLeftHand: Bool {return _storage._leftHand != nil}
  /// Clears the value of `leftHand`. Subsequent reads from it will return its default value.
  public mutating func clearLeftHand() {_uniqueStorage()._leftHand = nil}

  public var rightHand: MujocoAr_Hand {
    get {return _storage._rightHand ?? MujocoAr_Hand()}
    set {_uniqueStorage()._rightHand = newValue}
  }
  /// Returns true if `rightHand` has been explicitly set.
  public var hasRightHand: Bool {return _storage._rightHand != nil}
  /// Clears the value of `rightHand`. Subsequent reads from it will return its default value.
  public mutating func clearRightHand() {_uniqueStorage()._rightHand = nil}

  public var head: MujocoAr_Matrix4x4 {
    get {return _storage._head ?? MujocoAr_Matrix4x4()}
    set {_uniqueStorage()._head = newValue}
  }
  /// Returns true if `head` has been explicitly set.
  public var hasHead: Bool {return _storage._head != nil}
  /// Clears the value of `head`. Subsequent reads from it will return its default value.
  public mutating func clearHead() {_uniqueStorage()._head = nil}

  public var timestamp: Double {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request to start hand tracking stream
public struct MujocoAr_HandTrackingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sessionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "mujoco_ar"

extension MujocoAr_UsdzUrlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UsdzUrlRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}usdz_url\0\u{3}session_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.usdzURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.usdzURL.isEmpty {
      try visitor.visitSingularStringField(value: self.usdzURL, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MujocoAr_UsdzUrlRequest, rhs: MujocoAr_UsdzUrlRequest) -> Bool {
    if lhs.usdzURL != rhs.usdzURL {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MujocoAr_UsdzUrlResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UsdzUrlResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MujocoAr_UsdzUrlResponse, rhs: MujocoAr_UsdzUrlResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MujocoAr_UsdzDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UsdzDataRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}usdz_data\0\u{1}filename\0\u{3}session_id\0\u{3}attach_to_position\0\u{3}attach_to_rotation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.usdzData) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._attachToPosition) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._attachToRotation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.usdzData.isEmpty {
      try visitor.visitSingularBytesField(value: self.usdzData, fieldNumber: 1)
    }
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 2)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 3)
    }
    try { if let v = self._attachToPosition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._attachToRotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MujocoAr_UsdzDataRequest, rhs: MujocoAr_UsdzDataRequest) -> Bool {
    if lhs.usdzData != rhs.usdzData {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs._attachToPosition != rhs._attachToPosition {return false}
    if lhs._attachToRotation != rhs._attachToRotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MujocoAr_UsdzChunkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UsdzChunkRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}chunk_data\0\u{1}filename\0\u{3}session_id\0\u{3}chunk_index\0\u{3}total_chunks\0\u{3}total_size\0\u{3}is_last_chunk\0\u{3}attach_to_position\0\u{3}attach_to_rotation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.chunkData) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.chunkIndex) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.totalChunks) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.totalSize) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isLastChunk) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._attachToPosition) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._attachToRotation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.chunkData.isEmpty {
      try visitor.visitSingularBytesField(value: self.chunkData, fieldNumber: 1)
    }
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 2)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 3)
    }
    if self.chunkIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.chunkIndex, fieldNumber: 4)
    }
    if self.totalChunks != 0 {
      try visitor.visitSingularInt32Field(value: self.totalChunks, fieldNumber: 5)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularInt64Field(value: self.totalSize, fieldNumber: 6)
    }
    if self.isLastChunk != false {
      try visitor.visitSingularBoolField(value: self.isLastChunk, fieldNumber: 7)
    }
    try { if let v = self._attachToPosition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._attachToRotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MujocoAr_UsdzChunkRequest, rhs: MujocoAr_UsdzChunkRequest) -> Bool {
    if lhs.chunkData != rhs.chunkData {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.chunkIndex != rhs.chunkIndex {return false}
    if lhs.totalChunks != rhs.totalChunks {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.isLastChunk != rhs.isLastChunk {return false}
    if lhs._attachToPosition != rhs._attachToPosition {return false}
    if lhs._attachToRotation != rhs._attachToRotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MujocoAr_UsdzDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UsdzDataResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}message\0\u{3}local_file_path\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.localFilePath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.localFilePath.isEmpty {
      try visitor.visitSingularStringField(value: self.localFilePath, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MujocoAr_UsdzDataResponse, rhs: MujocoAr_UsdzDataResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.message != rhs.message {return false}
    if lhs.localFilePath != rhs.localFilePath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MujocoAr_Vector3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vector3"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}x\0\u{1}y\0\u{1}z\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.z) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    if self.z.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.z, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MujocoAr_Vector3, rhs: MujocoAr_Vector3) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MujocoAr_Quaternion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Quaternion"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}x\0\u{1}y\0\u{1}z\0\u{1}w\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.z) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.w) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    if self.z.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.z, fieldNumber: 3)
    }
    if self.w.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.w, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MujocoAr_Quaternion, rhs: MujocoAr_Quaternion) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.w != rhs.w {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MujocoAr_BodyPose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BodyPose"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}position\0\u{1}rotation\0\u{3}body_name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rotation) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bodyName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.bodyName.isEmpty {
      try visitor.visitSingularStringField(value: self.bodyName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MujocoAr_BodyPose, rhs: MujocoAr_BodyPose) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs._rotation != rhs._rotation {return false}
    if lhs.bodyName != rhs.bodyName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MujocoAr_PoseUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PoseUpdateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}body_poses\0\u{3}session_id\0\u{1}timestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.bodyPoses) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bodyPoses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bodyPoses, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 2)
    }
    if self.timestamp.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MujocoAr_PoseUpdateRequest, rhs: MujocoAr_PoseUpdateRequest) -> Bool {
    if lhs.bodyPoses != rhs.bodyPoses {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MujocoAr_PoseUpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PoseUpdateResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}message\0\u{3}bodies_updated\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.bodiesUpdated) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.bodiesUpdated != 0 {
      try visitor.visitSingularInt32Field(value: self.bodiesUpdated, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MujocoAr_PoseUpdateResponse, rhs: MujocoAr_PoseUpdateResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.message != rhs.message {return false}
    if lhs.bodiesUpdated != rhs.bodiesUpdated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MujocoAr_Matrix4x4: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Matrix4x4"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}m00\0\u{1}m01\0\u{1}m02\0\u{1}m03\0\u{1}m10\0\u{1}m11\0\u{1}m12\0\u{1}m13\0\u{1}m20\0\u{1}m21\0\u{1}m22\0\u{1}m23\0\u{1}m30\0\u{1}m31\0\u{1}m32\0\u{1}m33\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.m00) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.m01) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.m02) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.m03) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.m10) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.m11) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.m12) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.m13) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.m20) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self.m21) }()
      case 11: try { try decoder.decodeSingularFloatField(value: &self.m22) }()
      case 12: try { try decoder.decodeSingularFloatField(value: &self.m23) }()
      case 13: try { try decoder.decodeSingularFloatField(value: &self.m30) }()
      case 14: try { try decoder.decodeSingularFloatField(value: &self.m31) }()
      case 15: try { try decoder.decodeSingularFloatField(value: &self.m32) }()
      case 16: try { try decoder.decodeSingularFloatField(value: &self.m33) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.m00.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.m00, fieldNumber: 1)
    }
    if self.m01.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.m01, fieldNumber: 2)
    }
    if self.m02.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.m02, fieldNumber: 3)
    }
    if self.m03.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.m03, fieldNumber: 4)
    }
    if self.m10.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.m10, fieldNumber: 5)
    }
    if self.m11.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.m11, fieldNumber: 6)
    }
    if self.m12.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.m12, fieldNumber: 7)
    }
    if self.m13.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.m13, fieldNumber: 8)
    }
    if self.m20.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.m20, fieldNumber: 9)
    }
    if self.m21.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.m21, fieldNumber: 10)
    }
    if self.m22.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.m22, fieldNumber: 11)
    }
    if self.m23.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.m23, fieldNumber: 12)
    }
    if self.m30.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.m30, fieldNumber: 13)
    }
    if self.m31.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.m31, fieldNumber: 14)
    }
    if self.m32.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.m32, fieldNumber: 15)
    }
    if self.m33.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.m33, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MujocoAr_Matrix4x4, rhs: MujocoAr_Matrix4x4) -> Bool {
    if lhs.m00 != rhs.m00 {return false}
    if lhs.m01 != rhs.m01 {return false}
    if lhs.m02 != rhs.m02 {return false}
    if lhs.m03 != rhs.m03 {return false}
    if lhs.m10 != rhs.m10 {return false}
    if lhs.m11 != rhs.m11 {return false}
    if lhs.m12 != rhs.m12 {return false}
    if lhs.m13 != rhs.m13 {return false}
    if lhs.m20 != rhs.m20 {return false}
    if lhs.m21 != rhs.m21 {return false}
    if lhs.m22 != rhs.m22 {return false}
    if lhs.m23 != rhs.m23 {return false}
    if lhs.m30 != rhs.m30 {return false}
    if lhs.m31 != rhs.m31 {return false}
    if lhs.m32 != rhs.m32 {return false}
    if lhs.m33 != rhs.m33 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MujocoAr_HandSkeleton: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HandSkeleton"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}joint_matrices\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.jointMatrices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jointMatrices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.jointMatrices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MujocoAr_HandSkeleton, rhs: MujocoAr_HandSkeleton) -> Bool {
    if lhs.jointMatrices != rhs.jointMatrices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MujocoAr_Hand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Hand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}wrist_matrix\0\u{1}skeleton\0")

  fileprivate class _StorageClass {
    var _wristMatrix: MujocoAr_Matrix4x4? = nil
    var _skeleton: MujocoAr_HandSkeleton? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _wristMatrix = source._wristMatrix
      _skeleton = source._skeleton
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._wristMatrix) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._skeleton) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._wristMatrix {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._skeleton {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MujocoAr_Hand, rhs: MujocoAr_Hand) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._wristMatrix != rhs_storage._wristMatrix {return false}
        if _storage._skeleton != rhs_storage._skeleton {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MujocoAr_HandTrackingUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HandTrackingUpdate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}left_hand\0\u{3}right_hand\0\u{1}head\0\u{1}timestamp\0")

  fileprivate class _StorageClass {
    var _leftHand: MujocoAr_Hand? = nil
    var _rightHand: MujocoAr_Hand? = nil
    var _head: MujocoAr_Matrix4x4? = nil
    var _timestamp: Double = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _leftHand = source._leftHand
      _rightHand = source._rightHand
      _head = source._head
      _timestamp = source._timestamp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._leftHand) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._rightHand) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._head) }()
        case 4: try { try decoder.decodeSingularDoubleField(value: &_storage._timestamp) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._leftHand {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._rightHand {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._head {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._timestamp.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._timestamp, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MujocoAr_HandTrackingUpdate, rhs: MujocoAr_HandTrackingUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._leftHand != rhs_storage._leftHand {return false}
        if _storage._rightHand != rhs_storage._rightHand {return false}
        if _storage._head != rhs_storage._head {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MujocoAr_HandTrackingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HandTrackingRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}session_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MujocoAr_HandTrackingRequest, rhs: MujocoAr_HandTrackingRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
